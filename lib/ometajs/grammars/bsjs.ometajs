ometa BSJSParser {
  space        = ^@space | /^\/\/[^\n]*/ | /^\/\*(.|[\r\n])*?\*\//,
  nameFirst    = /^[a-z$_]/i,
  nameLast     = /^[a-z0-9$_]/i,
  iName        = /^[a-z$_][a-z0-9$_]*/i,
  isKeyword :x = ?BSJSParser._isKeyword(x),
  name         = @iName:n ~isKeyword(n)                                               -> [#name, n],
  keyword      = @iName:k isKeyword(k)                                                -> [k, k],
  hexDigit     = @char:x {BSJSParser.hexDigits.indexOf(x.toLowerCase())}:v ?(v >= 0)  -> v,
  hexLit       = hexLit:n hexDigit:d                                                  -> (n * 16 + d)
               | hexDigit,
  number       = /^0x[0-9a-f]+/:n                                                      -> [#number, parseInt(n)]
               | /^\d+((\.|[eE][\-+]?)\d+)?/:f                                         -> [#number, parseFloat(f)],
  escapeChar   = <'\\' char>:s -> {
                 switch (s) {
                   case '\\"': return '"';
                   case '\\\'': return '\'';
                   case '\\n': return '\n';
                   case '\\r': return '\r';
                   case '\\t': return '\t';
                   case '\\b': return '\b';
                   case '\\f': return '\f';
                   case '\\\\': return '\\';
                   default: return s.charAt(1);
                 }
               }
               | <'\\' ('u' hexDigit hexDigit hexDigit hexDigit
                      | 'x' hexDigit hexDigit)>:s -> {
                 JSON.parse('"' + s + '"')
               },
  str          = /^'([^'\\]|\\.)*'/:s -> {
                 function swap(quote) {
                   return quote === '"' ? '\'' : '"';
                 }
                 return [
                   #string,
                   JSON.parse(preparseString(s.replace(/["']/g, swap)))
                       .replace(/["']/g, swap)
                 ];
               }
               | /^"([^"\\]|\\.)*"/:s -> [#string, JSON.parse(preparseString(s))],
  special      = /^(>>>|<<<|!==|===|&&=|\|\|=|!=|==|>=|<=|\+\+|\+=|--|-=|\*=|\/=|%=|&&|\|\||>>|&=|\|=|\^=|[\(\){}\[\],;?:><=\+\-\*\/%&|\^~\.!])/:s -> [s, s],
  token        = @spaces (@name | @keyword | @number | @str | @special),
  toks         = @token*:ts @spaces end                                                -> ts,
  spacesNoNl   = (~'\n' space)*,

  expr = commaExpr,
  commaExpr = commaExpr:e1 "," asgnExpr:e2 -> [#binop, ",", e1, e2]
            | asgnExpr,
  asgnExpr     = condExpr:e ( "="   asgnExpr:rhs                                     -> [#set,  e, rhs]
                            | ( "+=" | "-=" | "*=" | "/="
                              | "&&=" | "||="
                              | "%=" | "<<=" | ">>=" | ">>>="
                              | "&=" | "^="  | "|=" ):op asgnExpr:rhs                -> [#mset, e, op.slice(0, -1), rhs]
                            | empty                                                  -> e
                            ),
  condExpr     = orExpr:e ( "?"   condExpr:t   ":" condExpr:f                        -> [#condExpr, e, t, f]
                          | empty                                                    -> e
                          ),
  orExpr       = orExpr:x "||" andExpr:y -> [#binop, '||', x, y]
               | andExpr,
  andExpr      = andExpr:x "&&" bitExpr:y -> [#binop, '&&', x, y]
               | bitExpr,
  bitExpr      = bitExpr:x ("|"|"^"|"&"):op eqExpr:y -> [#binop, op, x, y]
               | eqExpr,
  eqExpr       = eqExpr:x ("=="|"!="|"==="|"!=="):op relExpr:y                       -> [#binop, op,  x, y]
               | relExpr,
  relExpr      = relExpr:x (">"|">="|"<"|"<="|"instanceof"|"in"):op shiftExpr:y      -> [#binop, op,  x, y]
               | shiftExpr,
  shiftExpr    = shiftExpr (">>>"|"<<<"|">>"):op addExpr:y                           -> [#binop, op,  x, y]
               | addExpr,
  addExpr      = addExpr:x ("+"|"-"):op mulExpr:y                                    -> [#binop, op,  x, y]
               | mulExpr,
  mulExpr      = mulExpr:x ("*"|"/"|"%"):op unary:y                                  -> [#binop, op,  x, y]
               | unary,
  unary        = ("-"|"+"):op postfix:p                                              -> [#unop,  op,     p]
               | ("--"|"++"):op postfix:p                                            -> [#preop, op,     p]
               | ("!"|"~"|"void"|"delete"|"typeof"):op unary:p                       -> [#unop,  op,     p]
               | postfix,
  postfix      = primExpr:p ( spacesNoNl ("++"|"--"):op                              -> [#postop, op, p]
                            | empty                                                  -> p
                            ),

  dotProp :p   = "[" expr:i "]"                                                      -> [#getp, i, p]
               | "." "name":f                                                        -> [#getp, [#string, f], p]
               | "." spaces @iName:f isKeyword(f)                                    -> [#getp, [#string, f], p],

  primExpr     = primExpr:p ( "(" listOf(#asgnExpr, ','):as ")"                       -> [#call, p].concat(as)
                            | "." "name":m "(" listOf(#asgnExpr, ','):as ")"          -> [#send, m, p].concat(as)
                            | "." spaces @iName:m "(" listOf(#asgnExpr, ','):as ")"
                              isKeyword(m)                                            -> [#send, m, p].concat(as)
                            | dotProp(p):r -> r
                            )
               | memberExpr,
  memberExpr   = memberExpr:p dotProp(p):r -> r
               | newExpr,
  newExpr      = "new" memberExpr:n "(" listOf(#asgnExpr, ","):as ")"                -> [#new, n].concat(as)
               | "new" memberExpr:n                                                  -> [#new, n]
               | primExprHd,
  primExprHd   = "(" expr:e ")"                                                      -> e
               | "this"                                                              -> [#this]
               | "name":n                                                            -> [#get, n]
               | "number":n                                                          -> [#number, n]
               | "string":s                                                          -> [#string, s]
               | func(true)
               | "new" "name":n "(" listOf(#asgnExpr, ','):as ")"                    -> [#new, n].concat(as)
               | "new" "name":n                                                      -> [#new, n]
               | "[" listOf(#asgnExpr, ','):es "]"                                   -> [#arr].concat(es)
               | json
               | re,
  json         = "{" listOf(#jsonBinding, ','):bs "}"                                -> [#json].concat(bs),
  jsonBinding  = jsonPropName:n ":" asgnExpr:v                                       -> [#binding, n, v],
  jsonPropName = "name" | "number" | "string" | spaces @iName:n isKeyword(n)         -> n,
  re           = spaces <'/' reBody '/' reFlag*>:x                                   -> [#regExp, x],
  reBody       = re1stChar reChar*,
  re1stChar    = ~('*' | '\\' | '/' | '[') reNonTerm
               | escapeChar
               | reClass,
  reChar       = re1stChar | '*',
  reNonTerm    = ~('\n' | '\r') char,
  reClass      = '[' reClassChar* ']',
  reClassChar  = ~('[' | ']') reChar,
  reFlag       = nameFirst,
  formal       = spaces "name",
  func :anon   = "function" (?(anon) "name")?:n
                 "(" listOf(#formal, ','):fs ")" "{" srcElems:body "}"               -> [#func, n || null, fs, body],
  sc           = spacesNoNl ('\n' | &'}' | end)
               | ";",
  binding      = "name":n "=" asgnExpr:v                                             -> [n, v]
               | "name":n                                                            -> [n],
  block        = "{" srcElems:ss "}"                                                 -> ss,
  vars         = "var" listOf(#binding, ','):bs                                      -> [#var].concat(bs),
  stmt         = block
               | vars:bs sc                                                          -> bs
               | "if" "(" expr:c ")" stmt:t ( "else" stmt
                                            | empty -> [#get, 'undefined'] ):f       -> [#if, c, t, f]
               | "while" "(" expr:c ")" stmt:s                                       -> [#while,   c, s]
               | "do" stmt:s "while" "(" expr:c ")" sc                               -> [#doWhile, s, c]
               | "for" "(" ( vars
                           | expr
                           | empty -> [#get, 'undefined'] ):i
                       ";" ( expr
                           | empty -> [#get, 'true']      ):c
                       ";" ( expr
                           | empty -> [#get, 'undefined'] ):u
                       ")" stmt:s                                                    -> [#for, i, c, u, s]
               | "for" "(" ( "var" binding:b "in" asgnExpr:e                         -> [ [#var, b], e ]
                           | expr:e ?(e[0] === 'binop' && e[1] === 'in')             -> { e.slice(2) }
                           ):cond
                       ")" stmt:s                                                    -> [#forIn, cond[0], cond[1], s]
               | "switch" "(" expr:e ")" "{"
                   ( "case" asgnExpr:c ":" srcElems:cs -> [#case, c, cs]
                   | "default"     ":" srcElems:cs -> [#default, cs] )*:cs
                 "}"                                                                 -> [#switch, e].concat(cs)
               | "break" sc                                                          -> [#break]
               | "continue" sc                                                       -> [#continue]
               | "throw" spacesNoNl asgnExpr:e sc                                    -> [#throw, e]
               | "try" block:t "catch" "(" "name":e ")" block:c
                             ( "finally" block
                             | empty -> [#get, 'undefined'] ):f                      -> [#try, t, e, c, f]
               | "return" ( expr
                          | empty -> [#get, 'undefined'] ):e sc                      -> [#return, e]
               | "with" "(" expr:x ")" stmt:s                                        -> [#with, x, s]
               | @iName:label ":" stmt:s                                             -> [#label, label, s]
               | expr:e sc                                                           -> e
               | ";"                                                                 -> [#get, "undefined"],
  srcElem      = (func(false) | stmt):s                                              -> [#stmt, s],
  srcElems     = srcElem*:ss                                                         -> [#begin].concat(ss),

  topLevel     = srcElems:r spaces end                                               -> r
}
BSJSParser.hexDigits = "0123456789abcdef";
BSJSParser.keywords = { };
var keywords = [ "break", "case", "catch", "continue", "default", "delete",
                 "do", "else", "finally", "for", "function", "if", "in",
                 "instanceof", "new", "return", "switch", "this", "throw",
                 "try", "typeof", "var", "void", "while", "with", "ometa"];
for (var idx = 0; idx < keywords.length; idx++)
  BSJSParser.keywords[keywords[idx]] = true;
BSJSParser._isKeyword = function(k) {
  return BSJSParser.keywords.hasOwnProperty(k);
};

BSJSParser.reserved = { };
var reserved = [ "class", "enum", "export", "extends", "import", "super",
                 "implements", "interface", "let", "package", "private",
                 "protected", "public", "static", "yield" ];
for (var idx = 0; idx < keywords.length; idx++)
  BSJSParser.reserved[keywords[idx]] = true;
BSJSParser._isReserved = function(k) {
return BSJSParser.reserved.hasOwnProperty(k);
};

function preparseString(str) {
  return str.replace(/\\x([0-9a-f]{2})/ig, '\\u00$1');
}


ometa BSSemActionParser <: BSJSParser {
  curlySemAction = "{" asgnExpr:r sc "}" spaces                              -> r
                 | "{" (srcElem:s &srcElem -> s)*:ss
                       ( asgnExpr:r sc -> [#return, r] | srcElem):s {ss.push(s)}
                   "}" spaces                                                -> [#send, #call,
                                                                                        [#func, null, [], [#begin].concat(ss)],
                                                                                        [#this]],
  semAction      = curlySemAction
                 | primExpr:r spaces                                         -> r
}

ometa BSJSIdentity {
  trans      = [:t apply(t):ans]     -> ans
             | [:t] -> t,

  curlyTrans = [#begin curlyTrans:r] -> [#begin, r]
             | [#begin trans*:rs]    -> ([#begin].concat(rs))
             | trans:r               -> r,

  this                                                  -> [#this],
  break                                                 -> [#break],
  continue                                              -> [#continue],
  number   :n                                           -> [#number, n],
  string   :s                                           -> [#string, s],
  regExp   :x                                           -> [#regExp, x],
  arr      trans*:xs                                    -> ([#arr].concat(xs)),
  unop     :op trans:x                                  -> [#unop, op, x],
  get      :x                                           -> [#get, x],
  getp     trans:fd trans:x                             -> [#getp, fd, x],
  set      trans:lhs trans:rhs                          -> [#set, lhs, rhs],
  mset     trans:lhs :op trans:rhs                      -> [#mset, lhs, op, rhs],
  binop    :op trans:x trans:y                          -> [#binop, op, x, y],
  preop    :op trans:x                                  -> [#preop, op, x],
  postop   :op trans:x                                  -> [#postop, op, x],
  return   trans:x                                      -> [#return, x],
  with     trans:x curlyTrans:s                         -> [#with, x, s],
  label    :name trans:body                             -> [#label, name, body],
  if       trans:cond curlyTrans:t curlyTrans:e         -> [#if, cond, t, e],
  condExpr trans:cond trans:t trans:e                   -> [#condExpr, cond, t, e],
  while    trans:cond curlyTrans:body                   -> [#while, cond, body],
  doWhile  curlyTrans:body trans:cond                   -> [#doWhile, body, cond],
  for      trans:init trans:cond trans:upd
           curlyTrans:body                              -> [#for, init, cond, upd, body],
  forIn    trans:x trans:arr curlyTrans:body            -> [#forIn, x, arr, body],
  begin    trans:x end                                  -> ([#begin, x]),
  begin    trans*:xs                                    -> ([#begin].concat(xs)),
  func     :name :args curlyTrans:body                  -> [#func, name, args, body],
  call     trans:fn trans*:args                         -> ([#call, fn].concat(args)),
  send     :msg trans:recv trans*:args                  -> ([#send, msg, recv].concat(args)),
  new      ( anything:str ?(typeof str === 'string') -> str
           | trans
           ):cls trans*:args                            -> ([#new, cls].concat(args)),
  var      varItem+:vs                                  -> ([#var].concat(vs)),
  varItem = [:n trans:v]                                -> [n, v]
          | [:n]                                        -> [n],
  throw    trans:x                                      -> [#throw, x],
  try      curlyTrans:x :name curlyTrans:c curlyTrans:f -> [#try, x, name, c, f],
  json     trans*:props                                 -> ([#json].concat(props)),
  binding  :name trans:val                              -> [#binding, name, val],
  switch   trans:x trans*:cases                         -> ([#switch, x].concat(cases)),
  case     trans:x trans:y                              -> [#case, x, y],
  stmt     trans:s                                      -> [#stmt, s],
  default          trans:y                              -> [#default, y]
}

ometa BSJSTranslator {
  trans      = [:t apply(t):ans { this._cons(ans) }:r ] -> r,
  mtrans     = trans*:rs -> {
    this._arrcons(rs);
  },
  curlyTrans = [#begin curlyTrans:r] -> r
             | [#begin mtrans:rs]    -> {
               this._cons('{').cons(rs.join(';')).cons('}')
             } | trans:r -> this._cons('{').cons(r).cons('}'),

  this                                                  -> 'this',
  break                                                 -> 'break',
  continue                                              -> 'continue',
  number   :n                                           -> n,
  string   :s                                           -> JSON.stringify(s),
  regExp   :x                                           -> x,
  arr      %(this.op = '[]') mtrans:xs                  -> {
    this._cons('[').cons(xs.join(',')).cons(']')
  },
  unop     :op {this.op}:prevOp %(this.op = 'u' + op) trans:t -> {
    var res;
    if (op === 'typeof' || op === 'void' || op === 'delete') {
      res = this._cons(op).cons(' ').cons(t);
    } else {
      res = this._cons(op).cons(t);
    }

    if (BSJSTranslator.comparePriorities(prevOp, 'u' + op)) {
      res = this._cons('(').cons(res).cons(')');
    }

    return res;
  },
  getp    %(this.op = '.') :fd trans(fd):tfd trans:x                    -> {
    if (fd[0] === 'string' && /^[$_a-z0-9][a-z0-9]*$/i.test(fd[1]) &&
        !BSJSParser._isKeyword(fd[1]) && !BSJSParser._isReserved(fd[1])) {
      return x + '.' + fd[1];
    } else {
      return this._cons(x).cons('[').cons(tfd).cons(']');
    }
  },
  get      :x                                           -> x,
  set {this.op}:prevOp trans:lhs %(this.op = '=') trans:rhs   -> {
    var res = lhs.cons(' = ').cons(rhs);
    if (BSJSTranslator.comparePriorities(prevOp, '=')) {
      res = this._cons('(').cons(res).cons(')');
    }
    return res;
  },
  mset {this.op}:prevOp trans:lhs :op %(this.op = op + '=')
       trans:rhs -> {
    var res = lhs.cons(' ' + op + '= ').cons(rhs);
    if (BSJSTranslator.comparePriorities(prevOp, op + '=')) {
      res = this._cons('(').cons(res).cons(')');
    }
    return res;
  },
  binop    :op {this.op}:prevOp %(this.op = op) trans:x trans:y -> {
    var res = x.cons(' ' + op + ' ').cons(y);

    if (BSJSTranslator.comparePriorities(prevOp, op)) {
      res = this._cons('(').cons(res).cons(')');
    }
    return res;
  },
  preop    :op {this.op}:prevOp %(this.op = 'u' + op) trans:x            -> {
    var res = this._cons(op).cons(x);

    if (BSJSTranslator.comparePriorities(prevOp, 'u' + op)) {
      res = this._cons('(').cons(res).cons(')');
    }

    return res;
  },
  postop   :op {this.op}:prevOp %(this.op = 'u' + op) trans:x            -> {
    var res = x.cons(op);

    if (BSJSTranslator.comparePriorities(prevOp, 'u' + op)) {
      res = this._cons('(').cons(res).cons(')');
    }

    return res;
  },
  return   trans:x                              -> {
    this._cons('return ').cons(x)
  },
  with     trans:x curlyTrans:s                 -> {
    this._cons('with(').cons(x).cons(')').cons(s)
  },
  label    :name curlyTrans:s                   -> {
    this._cons(';' + name + ':').cons(s)
  },
  if       trans:cond curlyTrans:t curlyTrans:e -> {
    this._cons('if(').cons(cond).cons(')').cons(t).cons('else').cons(e)
  },
  condExpr {this.op}:prevOp %(this.op = '?:') trans:cond trans:t trans:e -> {
    var res = cond.cons('?').cons(t).cons(':').cons(e);

    if (BSJSTranslator.comparePriorities(prevOp, '?:')) {
      res = this._cons('(').cons(res).cons(')');
    }
    return res;
  },
  while    trans:cond curlyTrans:body -> {
    this._cons('while(').cons(cond).cons(')').cons(body)
  },
  doWhile  curlyTrans:body trans:cond -> {
    this._cons('do').cons(body).cons('while(').cons(cond).cons(')')
  },
  for      trans:init trans:cond trans:upd curlyTrans:body -> {
    this._cons('for(').cons(init).cons(';')
                      .cons(cond).cons(';')
                      .cons(upd).cons(')')
                      .cons(body)
  },
  forIn    trans:x trans:arr curlyTrans:body            -> {
    this._cons('for(').cons(x).cons(' in ').cons(arr).cons(')').cons(body)
  },
  begin    trans:x end                                  -> x,
  begin    (trans:x
              ( end -> x
              | empty                                   -> x.cons(';')
              )
           )*:xs -> this._cons('{').cons(xs.join('')).cons('}'),
  func     :name :args curlyTrans:body                  -> {
    this._cons('function ' + (name || '') + '(' + args.join(',') + ')')
        .cons(body)
  },
  call     :fn trans(fn):tfn %(this.op = '()') mtrans:args                -> {
    if (fn[1] === null) tfn = this._cons('(').cons(tfn).cons(')');
    return tfn.cons('(').cons(args.join(',')).cons(')');
  },
  send     :msg trans:recv mtrans:args                  -> {
    recv.cons('.' + msg + '(').cons(args.join(',')).cons(')')
  },
  new      ( anything:str ?(typeof str === 'string') -> str
           | trans
           ):cls mtrans:args                            -> {
    this._cons('new ').cons(cls).cons('(').cons(args.join(',')).cons(')')
  },
  var      varItem+:vs                                  -> {
    this._cons('var ').cons(vs.join(','))
  },
  varItem = [:n :v trans(v):tv]                         -> {
    var res = this._cons(n + ' = ');
    if (v[0] === 'binop' && v[1] === ',') {
      res = res.cons('(').cons(tv).cons(')');
    } else {
      res = res.cons(tv);
    }
  } | [:n]                                              -> this._cons(n),
  throw    trans:x                                      -> {
    this._cons('throw ').cons(x)
  },
  try      curlyTrans:x :name curlyTrans:c curlyTrans:f -> {
    this._cons('try ').cons(x).cons('catch(' + name + ')').cons(c).cons('finally').cons(f)
  },
  json     %(this.op = '{}') mtrans:props               -> {
    this._cons('{').cons(props.join(',')).cons('}')
  },
  binding  :name trans:val                              -> {
    this._cons(JSON.stringify(name) + ': ').cons(val)
  },
  switch   trans:x mtrans:cases                         -> {
    this._cons('switch(').cons(x).cons('){').cons(cases.join(';')).cons('}')
  },
  case     trans:x trans:y                              -> {
    this._cons('case ').cons(x).cons(': ').cons(y)
  },
  default          trans:y                              -> {
    this._cons('default: ').cons(y)
  },
  stmt     :s trans(s):t                                -> {
    if (s[0] === 'function' && s[1] === null || s[0] === 'json') {
      return this._cons('(').cons(t).cons(')');
    }
    return t;
  }
}

BSJSTranslator.opPriorities = {
  '.': 0, '[]': 0, '()': 0, '{}': 0,
  'u++': 1, 'u--': 1,
  'u+': 2, 'u-': 2, 'u!': 2, 'u~': 2, 'utypeof': 2, 'uvoid': 2, 'udelete': 2,
  '*': 3, '/': 3, '%': 3,
  '+': 4, '-': 4,
  '<<': 5, '<<<': 5, '>>': 5,
  '<': 6, '<=': 6, '>': 6, '>=': 6,
  '==': 7, '===': 7, '!=': 7, '!==': 7,
  '&': 8,
  '^': 9,
  '|': 10,
  '&&': 11,
  '||': 12,
  '?:': 13,
  '=': 14, '+=': 14, '-=': 14, '*=': 14, '/=': 14, '%=': 14, '<<=': 14,
  '>>=': 14, '>>>=': 14, '&=': 14, '^=': 14, '|=': 14,
  ',': 15
};

BSJSTranslator.comparePriorities = function (op1, op2) {
  return op1 != undefined &&
      BSJSTranslator.opPriorities[op1] === undefined ||
      BSJSTranslator.opPriorities[op1] < BSJSTranslator.opPriorities[op2];
};
